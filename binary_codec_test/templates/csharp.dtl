using System;

public namespace yaski.codecs.{{codecname}}
{
{% with classname = codecname|pascal_case|add:"Client" %}
	public partial class {{ classname }}
	{
		
		// -===== To Server =====-
		private byte[] buffer = new byte[256];

{% for p in packets|filter_packets:"server" %}
{% with packetname = p.name|pascal_case %}
	{% if p.variables %}

{% include "csharp/type.dtl" with scope="private" name=packetname|add:"Type" %}
		private void {{packetname}}({{packetname|add:"Type"}} arg)
		{
            int offset = 1;
	    {% for v in p.variables %}
    		offset = Encode(buffer, offset, arg.{{v.name}});
		{% endfor %}
			Send(this, {{p.tag}}, buffer, offset);
		}

  {% else %}
		private void {{packetname}}()
		{
			Send(this, {{p.tag}});
		}
  {% endif %}

{% endwith %}
{% endfor %}

		// -===== From Server =====-

		// FOR EACH PACKET IN CLIENT

        // IF HAS DATA
{% include "csharp/type.dtl" with scope="public" name="TYPE" %}
		partial void OnMETHOD_CD(TYPE arg);

		// ELSE
		partial void OnMETHOD_C();

		// END

		// -===== Implementation =====-

		public static void Call({{ classname }} client, byte[] data, int length)
		{
			if (length > 0) {
				switch (data[0])
				{
				// FOR EACH PACKET
				case TYPE:
    				// IF HAS DATA
				    TYPE arg();
{% include "csharp/decode.dtl" %}
{% include "csharp/decode.dtl" %}
{% include "csharp/decode.dtl" %}
					client.OnMETHOD_CD(arg);
					// ELSE
					client.OnMETHOD_C();
					// END
					break;
				}
				// END
			}
		}

		public static void Send({{ classname }} client, byte type)
		{
            Send(client, type, buffer, 1);
		}

		public static void Send({{ classname }} client, byte type, byte[] data, int length)
		{
            data[0] = type;
		}

		private static int Encode(byte[] data, int offset, byte value)
		{
			data[offset] = value;
			return offset + 1;
		}

		private static int Encode(byte[] data, int offset, byte[] value)
		{
			int len = value.Length;
			offset = Encode(data, offset, len);
			Array.Copy(data, offset, value, 0, len)
			return offset + len;
		}

		private static int Encode(byte[] data, int offset, int value)
		{
			if (BitConverter.IsLittleEndian)			
			{
				data[offset] = (byte)(value >> 24);
				data[offset + 1] = (byte)(value >> 16);
				data[offset + 2] = (byte)(value >> 8);
				data[offset + 3] = (byte)(value);
			}
			else
			{
				data[offset + 1] = (byte)(value);
				data[offset + 2] = (byte)(value >> 8);
				data[offset + 3] = (byte)(value >> 16);
				data[offset + 4] = (byte)(value >> 24);
			}
			return offset + 4;
		}

		private static int Encode(byte[] data, int offset, float value)
		{
			byte[] bytes = BitConverter.GetBytes(value);
			if (BitConverter.IsLittleEndian)
			    Array.Reverse(bytes);
			Array.Copy(data, offset, bytes, 0, 4)
			return offset + 4;
		}
		
	}
{% endwith %}
}
